# Алгоритмы балансировки нагрузки  

Ключевой элемент балансировки нагрузки на сервер — это применяемый алгоритм. Мы рассмотрим самые простые и популярные, которые часто применяются на практике. Эти методы позволяют сгладить нагрузку и снижают риск падения сайта во время непредвиденной пиковой посещаемости.

## Общие принципы
Выбирая или разрабатывая алгоритм, нужно придерживаться трех принципов:

1. Справедливость. Каждый запрос должен обрабатываться. Нельзя допустить, чтобы запросы стояли в очереди друг за другом. Поэтому перед разработкой алгоритма балансировки нужно проверить нагрузку на сервер в динамике, чтобы знать, к каким скачкам нужно готовиться.

2. Рациональность. Все серверы из пула должны работать. Желательно — всегда и на полную мощность. Это не всегда достижимо, и задача алгоритма — распределить нагрузку максимально равномерно.

3. Скорость. Хороший балансирующий алгоритм обеспечивает быструю обработку запросов.

## 1. Round Robin («цикличный перебор»)

Round Robin, или алгоритм кругового обслуживания, представляет собой перебор по круговому циклу: первый запрос передаётся одному серверу, затем следующий запрос передаётся другому и так до достижения последнего сервера, а затем всё начинается сначала.

![](https://www.cisco.com/en/US/i/200001-300000/220001-230000/224001-225000/224609.jpg)

***Особенности:***

1. Равномерность распределения: Round Robin обеспечивает равномерное распределение запросов между серверами. Каждый сервер получает равный объем нагрузки в соответствии с установленным порядком выбора.

2. Простота реализации: Этот алгоритм относительно прост в реализации и не требует сложных вычислений или специализированного оборудования.

3. Поддержка отказоустойчивости: Если один из серверов становится недоступным, Round Robin может автоматически перенаправлять запросы на доступные серверы, обеспечивая непрерывность обслуживания пользователей.

4. Отсутствие учета нагрузки сервера: Round Robin не учитывает текущую нагрузку на серверы. В результате, если один сервер становится перегруженным, а другой - свободным, все равно будет распределение задач между ними.

5. Поддержка сессий: Round Robin не гарантирует сохранение сессии пользователя на одном и том же сервере. Возможно, что запросы от одного пользователя могут быть обработаны разными серверами.

***Достоинства:***  

- Для работы по алгоритму Round Robin используется любой протокол, в котором обращение к серверу идёт по имени.  
- Балансировка на основе алгоритма Round Robin никак не зависит от нагрузки на сервер: кэширующие DNS-серверы помогут справиться с любым наплывом клиентов.  
- Использование алгоритма Round Robin не требует связи между серверами, поэтому он может использоваться как для локальной, так и для глобальной балансировки.  
- Низкая стоимостью: чтобы алгоритмы начали работать, достаточно просто добавить несколько записей в DNS.  

***Недостатки:***  

- Чтобы распределение нагрузки отвечало критериями справедливости и эффективности, нужно, чтобы у каждого сервера был в наличии одинаковый набор ресурсов.   
- При выполнении всех операций должно быть задействовано одинаковое количество ресурсов. В реальной практике эти условия в большинстве случаев оказываются невыполнимыми.  
- При балансировке по алгоритму Round Robin совершенно не учитывается загруженность того или иного сервера в составе кластера.  

В силу описанных выше обстоятельств сфера применения алгоритма Round Robin весьма ограничена.  

## 2. Weighted Round Robin («взвешенный цикличный перебор»)  

Это — усовершенствованная версия алгоритма Round Robin. Суть усовершенствований заключается в следующем: каждому серверу присваивается весовой коэффициент в соответствии с его производительностью и мощностью. Это помогает распределять нагрузку более гибко: серверы с большим весом обрабатывают больше запросов. Однако всех проблем с отказоустойчивостью это отнюдь не решает. Более эффективную балансировку обеспечивают другие методы, в которых при планировании и распределении нагрузки учитывается большее количество параметров.  

![](https://webhostinggeeks.com/blog/wp-content/uploads/2023/07/Weighted-Round-Robin-980x744-optimized.png)

***Особенности:***

1. Весовые коэффициенты: Каждому серверу назначается весовой коэффициент, который определяет его способность обрабатывать запросы. Серверы с более высоким весом получают больше запросов, чем серверы с более низким весом.

2. Круговой порядок: Серверы упорядочиваются в круговой очереди, и запросы последовательно передаются от первого сервера к последнему. Когда достигается последний сервер в очереди, обработка запросов начинается снова с первого сервера.

3. Учет весовых коэффициентов: При передаче запроса каждому серверу присваивается весовое значение в соответствии с его весом. Это определяет, сколько запросов будет передано каждому серверу за один цикл обработки.

4. Адаптивность: Алгоритм WRR адаптируется к изменениям в нагрузке, позволяя серверам с более высокой производительностью обрабатывать больше запросов и, таким образом, равномерно распределять нагрузку между всеми серверами.

***Достоинства:*** 

- Простая настройка.  
- Дешевизна.  
- Возможность присвоить каждой машине весовой коэффициент — коэффициент допустимой нагрузки.

***Недостатки:***   

- Сложность настройки весовых коэффициентов  
- Статическое распределение запросов в соответствии с весовыми коэффициентами, что не учитывает изменяющиеся условия нагрузки.  
- На практике ручное указание весов быстро оказывается неэффективным. Сложно свести производительность сервера к одному числу, и для этого потребуется тщательное тестирование нагрузок с реальными рабочими нагрузками. Это делают редко, поэтому другой вариант weighted round robin вычисляет веса динамически при помощи вспомогательной метрики: задержки.  

WRR является эффективным методом балансировки нагрузки, который позволяет равномерно распределять запросы на сервера с учетом их производительности. Он широко применяется в сетевых инфраструктурах, таких как балансировщики нагрузки и маршрутизаторы, для оптимизации работы и предотвращения перегрузок серверов.

## 3. Least Connections (алгоритм наименьших соединений)  

Этот алгоритм учитывает количество подключений, поддерживаемых серверами в текущий момент времени. Каждый следующий вопрос передаётся серверу с наименьшим количеством активных подключений.  
Поскольку производится отслеживание активных подключений к активным серверам с помощью таблицы IPVS, этот алгоритм использует динамическое планирование, что делает его лучшим выбором для ситуаций, когда возможен большой разброс значений нагрузки. Он наилучшим образом подходит для пула реальных серверов, где все ноды имеют примерно одинаковую производительность. Если же мощности реальных серверов значительно отличаются, алгоритм «Минимум подключений c использованием весовых коэффициентов» будет лучшим выбором.

![](https://www.nginx.com/wp-content/uploads/2018/11/least-conn_power-of-two-choices.png)

***Особенности:***

1. Распределение нагрузки на основе количества активных соединений: Алгоритм отслеживает число текущих соединений каждого сервера и выбирает тот, у которого наименьшее количество.

2. Динамическое обновление: Число активных соединений постоянно обновляется на основе запросов от клиентов. Это позволяет алгоритму быстро реагировать на изменения возникающей нагрузки.

3. Балансировка нагрузки на основе реальной загрузки серверов: Алгоритм учитывает реальное состояние серверов, а не только их доступность. Это позволяет равномерно распределять нагрузку и предотвращать перегрузку отдельных серверов.

4. Поддержка сеансов: Алгоритм учитывает отдельные сеансы пользователей при принятии решения о направлении запросов. Это предотвращает разрывы сеансов и обеспечивает более плавное и непрерывное обслуживание.

5. Простота реализации: Алгоритм Least Connections относительно прост в реализации и не требует сложных вычислений или больших вычислительных ресурсов.

***Достоинства:*** 

- Простота реализации.
- Хорошо работает вне зависимости от степени колебаний.
- Учитывает не только нагрузку на оборудование, но и количество подключений. Благодаря этому трафик в сети распределяется “справедливо” — то есть с учетом большего числа критериев.  

***Недостатки:***   

- Если пользователь автоматически переподключится к другому серверу, ему нужно будет авторизоваться заново. Это будет происходить каждый раз при перенаправлении пользовательского запроса к другому серверу.  
- Не учитывает производительность серверов и может направлять запросы на медленные серверы, если количество соединений одинаково.  

В целом, алгоритм Least Connections является эффективным способом балансировки нагрузки, который помогает обеспечить равномерное распределение запросов между серверами и обеспечить быструю и надежную работу системы.

Существует несколько усовершенствованных вариантов реализации алгоритма LeastConnections, например:  

- Weighted Least-Connections
- Locality-Based Least Connection Scheduling;  
- Locality-Based Least Connection Scheduling with Replication Scheduling;  

**Минимум подключений c использованием весовых коэффициентов (Weighted Least-Connections) (используется по умолчанию)**   

 Распределяет большее количество запросов серверам с наименьшим количеством активных подключений в соответствии с их производительностью. Производительность обозначается назначенным администратором весовым коэффициентом, который впоследствии корректируется с использованием динамической информации о загрузке. Введение весовых коэффициентов делает этот алгоритм идеальным для случаев, когда пул реальных серверов содержит различные по производительности конфигурации.  
 
**Минимум подключений с учётом местоположения (Locality-Based Least-Connection Scheduling)**   

Распределяет большее количество запросов серверам с наименьшим количеством активных подключений в соответствии с IP адресата. Этот алгоритм разработан для использования в кластерах кеширующих прокси-серверов. Его суть заключается в следующем: наибольшее количество запросов передаётся серверам с наименьшим количеством активных подключений. За каждым из клиентских серверов закрепляется группа клиентских IP. Запросы с этих IP направляются на «родной» сервер, если он не загружен полностью. В противном случае запрос будет перенаправлен на другой сервер (он должен быть загружен менее чем наполовину).  

**Минимум подключений с учётом местоположения и репликацией (Locality-Based Least-Connection Scheduling with Replication Scheduling)**  

 Распределяет большее количество запросов серверам с наименьшим количеством активных подключений в соответствии с IP адресата. От предыдущего алгоритма его отличает то, что каждый IP-адрес или группа IP-адресов закрепляется не за отдельным сервером, а за целой группой серверов. Запрос передаётся наименее загруженному серверу из группы. Если же все серверы из «родной» группы перегружены, то будет зарезервирован новый сервер. Этот новый сервер будет добавлен к группе, обслуживающей IP, с которого был отправлен запрос. В свою очередь наиболее загруженный сервер из этой группы будет удалён — это позволяет избежать избыточной репликации.  
 
## 4. IP Hash (хеширование IP-адреса)  

Алгоритм балансировки нагрузки IP Hash основывается на хешировании IP-адреса клиента для распределения нагрузки между несколькими серверами. В кратком описании этого алгоритма:

1. Когда клиент отправляет запрос к балансировщику нагрузки, его IP-адрес хешируется.
2. Полученное значение хеша используется для определения, на какой сервер направить запрос.
3. Балансировщик нагрузки использует хеш для выбора сервера из предопределенного набора.
4. Запрос направляется на выбранный сервер, который обрабатывает запрос и возвращает результат клиенту.

![](https://user-images.githubusercontent.com/19408342/69062528-08d71500-0a56-11ea-9838-72cefb4b3405.png)

***Особенность IP Hash*** состоит в том, что при поступлении одного и того же IP-адреса каждый раз будет выбран один и тот же сервер. Это основывается на предположении, что один и тот же клиент будет продолжать использовать один и тот же IP-адрес в течение сессии.

IP Hash может быть полезен при балансировке нагрузки веб-серверов или кэш-серверов, так как обеспечивает равномерное распределение трафика между серверами, основываясь на IP-адресе клиента. Однако, если IP-адрес клиента меняется при каждом запросе, это может привести к неравномерному распределению нагрузки между серверами.

Важно отметить, что IP Hash является одним из множества алгоритмов балансировки нагрузки, и его эффективность зависит от конкретного сценария использования и особенностей сетевой инфраструктуры.

***Достоинства:***   
- Равномерное распределение нагрузки между серверами.
- Высокая производительность и увеличение пропускной способности системы.
- Прост в реализации и не требует особой конфигурации.  

***Недостатки:***  
- Если изменяется состав серверов (например, добавление или удаление сервера), то перераспределение нагрузки будет неэффективным, так как играют роль только IP-адреса клиентов. Это может привести к ухудшению производительности системы.  
- Не учитывает текущую нагрузку на каждый сервер, что может привести к перегрузке некоторых серверов и недостаточному использованию ресурсов других серверов.  
- Не учитывает маршруты пакетов и не всегда является оптимальным для определенных сетевых архитектур.

Разделяется на:  

- Хеш получателя (Destination Hash Scheduling)  
Распределяет запросы в пуле реальных серверов в соответствии с IP получателя из статической hash-таблицы. Этот алгоритм спроектирован для работы с кластером кеширующих прокси-серверов.  

- Хеш отправителя (Source Hash Scheduling)
Распределяет запросы в пуле реальных серверов в соответствии с IP отправителя из статической hash-таблицы. Этот алгоритм спроектирован для работы с кластером кеширующих прокси-серверов.

## 5. Рeak exponentially weighted moving average или PEWMA (Пиковая экспоненциально взвешенная скользящая средняя) 

Этот алгоритм сочетает методики из dynamic weighted round robinс методиками из least connections, а поверх добавляет немного своей магии.  
Для каждого сервера алгоритм отслеживает задержку последних N запросов. Вместо того, чтобы использовать её как среднее, он суммирует значения, но экспоненциально снижает коэффициент масштаба. Это приводит к тому, что чем старее задержка, тем меньше она влияет на сумму. Недавние запросы влияют на расчёт сильнее, чем старые.
Затем это значение умножается на количество открытых соединений с сервером, и результатом этого становится значение, которое мы используем для выбора сервера, которому будем отправлять следующий запрос. Чем меньше значение, тем лучше.
Изначально производительность лучше, но со временем алгоритм начинает вести себя хуже, чем least connections. Это логично. PEWMA оппортунистичен, он пытается добиться наилучшей задержки, а это значит, что он иногда может обеспечивать неполную загрузку сервера.  

***Достоинства:***  
- Способность предотвращать перегрузку серверов и обеспечивать равномерное распределение нагрузки, даже при изменяющихся условиях.  
- Обладает гибкостью и настраиваемостью, позволяя установить различные параметры сглаживания в зависимости от требований системы.  

***Недостатки:***  
- Требует вычисления и обновления значений нагрузки для каждого сервера, что может привести к увеличению вычислительной сложности и задержке обработки запросов.  
- Может дать неверную оценку нагрузки в случае резких и кратковременных пиков. Такие скачки могут стать причиной перегрузки сервера и ухудшения производительности системы.  

## 6. Least Response Time (Наименьшее время отклика)

Этот алгоритм направляет запросы на сервер с наименьшим временем ответа. Он измеряет время, которое каждый сервер требует для обработки запроса и направляет следующий запрос на сервер с наименьшим временем ответа. Это полезно для обработки запросов с разной интенсивностью и позволяет маршрутизировать запросы на наиболее отзывчивый сервер.

![](https://wiki.merionet.ru/images/chto-takoe-balansirovka-nagruzki-v-seti/4.png)

***Особенности:***

1. Мониторинг времени отклика серверов: LRT отслеживает время отклика каждого сервера и ресурса для выбора наиболее быстрого и отзывчивого из них.

2. Выбор самого быстрого сервера: LRT выбирает сервер или ресурс с наименьшим временем отклика на запросы клиентов. Это позволяет распределить нагрузку равномерно и минимизировать задержки.

3. Динамическое обновление: LRT постоянно мониторит время отклика серверов и обновляет свою выборку, чтобы адаптироваться к изменяющейся нагрузке. Если время отклика сервера увеличивается, LRT может перенаправить запросы на другой более быстрый сервер.

4. Учет загрузки серверов: LRT также может учитывать текущую загрузку серверов или ресурсов при выборе наиболее быстрого. Это позволяет избежать перегруженности определенных серверов и равномерно распределить загрузку.

***Достоинства:***  

- Учитывает текущую производительность серверов.Серверы с более низкой задержкой получают больше запросов,это позволяет обеспечить быстрый ответ клиентам.  
- Способствует более равномерному распределению нагрузки.  
- Адаптируется к изменяющейся нагрузке и производительности серверов.Если сервер становится более медленным ,то алгоритм направляет меньше запросов на этот сервер.  

***Недостатки:***  

- Время ответа может изменяться в зависимости от условий нагрузки.  
- Алгоритм может не всегда выбирать сервер с самым маленьким временем ответа.  
- Сложность конфигурации :настройка параметров может потребовать определенной экспертизы и анализа данных о производительности серверов.  

Данный алгоритм является эффективным алгоритмом балансировки нагрузки,особенно в средах,где производительность серверов изменяется со временем .Однако он имеет свои ограничения и требует тщательной настройки и мониторинга для обеспечения оптимальной работы.  

## 7. Adaptive Load Balancing (адаптивная балансировка нагрузки) 

Этот алгоритм предоставляет динамическую настройку балансировки нагрузки на основе текущих условий и состояния серверов. Он контролирует производительность каждого сервера и регулирует маршрутизацию запросов в реальном времени. Это позволяет эффективно распределять нагрузку, учитывая изменяющиеся условия, но требует дополнительных ресурсов для контроля и адаптации.  

***Особенности:***

1. Динамическое анализирование нагрузки: Алгоритм непрерывно мониторит различные метрики, такие как загрузка процессора, использование сети и памяти, для определения текущей нагрузки на систему.

2. Адаптивное распределение: Базируясь на актуальной нагрузке, алгоритм решает, как распределить задачи между доступными ресурсами. Например, он может перенаправлять запросы на менее загруженные вычислительные узлы или использовать дополнительные ресурсы для обработки временно повышенной нагрузки.

3. Автоматическое масштабирование: Алгоритм может автоматически масштабировать количество ресурсов, используемых для обработки нагрузки, на основе изменений условий. Например, при росте загрузки он может запускать новые экземпляры приложений или добавлять вычислительные узлы для распределения задач.

4. Учет контекста: Алгоритм также учитывает контекст работы системы и индивидуальные особенности приложений. Например, он может предпочесть распределять задачи на узлы, где уже выполняются подобные задачи, чтобы повысить эффективность обработки.

5. Проактивное реагирование на изменения: Алгоритм быстро реагирует на изменения в нагрузке и динамически адаптирует балансировку ресурсов. Это позволяет системе эффективно работать даже при неожиданных скачках нагрузки.

6. Оптимизация производительности: Алгоритм стремится достичь максимальной производительности системы, эффективно распределяя задачи и управляя ресурсами.

***Достоинства:***  
- Способность адаптироваться к изменяющимся условиям и нагрузке. Он учитывает текущую производительность серверов ,нагрузку и другие параметры для принятия решений о распределении запросов.
- Обеспечивает оптимальную производительность системы, создают маршруты к серверам ,которые наилучшим образом способны обработать эти запросы в данный момент.  
- Алгоритм собирает и анализирует данные о производительности серверов ,нагрузке и других метриках для принятия более информативных решений.  

***Недостатки:***  

- Требует сбора и анализа большого объема данных;  
- Может быть более сложной в настройке и интеграции.  

Алгоритм Adaptive Load Balancing предлагает эффективное решение для обеспечения надежной и эффективной балансировки нагрузки в распределенных системах, учитывая сложности и изменения требований пользователей.
